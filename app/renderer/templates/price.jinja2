{% extends "base.jinja2" %}

{% block content %}
    <style>
        #chart-container {
            position: absolute;
            top: 12%;
            left: 3%;

            right: 3%;
            bottom: 32%;
            padding: 10px;
            padding-left: 20px;

            font-family: ThorFontLight, serif;
            font-weight: lighter;
        }

        .legend {
            position: absolute;
            top: 5%;
            left: 3%;
            display: flex;
        }

        .legend-item {
            display: flex;
            margin-right: 20px;
        }

        .legend-color {
            width: 27px;
            height: 25px;
            margin-right: 10px;
            border-radius: 5px;
        }

        .legend-text {
            color: #bbb;
            font-size: 20px;
            font-weight: bolder;
        }

        #price-chart {
            width: 100%;
            height: 100%;
        }

        .shadow-box, .indicator-box {
            border-radius: 22px;
            background: rgba(52, 51, 51, 0.21);
            box-shadow: rgb(0, 0, 0, 0.5) 0 0 20px;
        }

        .indicator-container {
            position: absolute;
            bottom: 8%;
            left: 3%;
            right: 3%;
            top: 70%;

            display: flex;
            flex-direction: row;
            align-items: stretch;
            flex-wrap: nowrap;
            justify-content: space-between;
        }

        .indicator-box {
            display: flex;
            padding: 12px;

            background: rgba(52, 51, 51, 0.21);
            border-radius: 12px;
            font-family: ThorFontLight, serif;
            justify-content: space-between;
            flex-direction: column;
            align-items: center;
            width: auto;
        }

        .chain-state-container {
            position: absolute;
            bottom: 3.6%;
            left: 4%;
            display: flex;
        }

        .chain-state {
            display: flex;
            align-items: center; /* Align items vertically */
        }

        .chain-state-name {
            color: #bbb;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            margin-right: 30px;
        }

        .chain-state-status {
            display: flex;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .ok {
            background-color: #26a69a;
        }

        .halted {
            background-color: #ef5350;
        }

        .warning {
            background-color: #FFA500;
        }
    </style>

    <script src="renderer/static/js/lightweight-charts.standalone.production.js"></script>

    {% with title="RUNE MARKET DATA" %}
        {% include "components/header.jinja2" %}
    {% endwith %}


    <div id="chart-container" class="shadow-box">
        <div id="price-chart"></div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #26a69a"></div>
                <div class="legend-color" style="background-color: #ef5350"></div>
                <div class="legend-text">Pool price</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(0, 204, 255, 0.8)"></div>
                <div class="legend-text">CEX price</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(100, 255, 200, 0.9)"></div>
                <div class="legend-text">Deterministic price</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(80,240,255,0.3)"></div>
                <div class="legend-text">Pool swap volume</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(13,189,120,0.4)"></div>
                <div class="legend-text">Trade asset volume</div>
            </div>
        </div>
    </div>

    <div class="indicator-container">
        <div class="indicator-box">
            1
        </div>

        <div class="indicator-box">
            2
        </div>

        <div class="indicator-box">
            3
        </div>

        <div class="indicator-box">
            4
        </div>

        <div class="indicator-box">
            5
        </div>
    </div>

    <div class="chain-state-container">
        {% for c in chain_state %}
            <div class="chain-state">
                <div class="chain-state-status {{ c[1] }}"></div>
                <div class="chain-state-name">{{ c[0] }}</div>
            </div>
        {% endfor %}
    </div>


    <script>
        const INTERVAL = 2 * 60 * 60  // 2 hours

        function convertToOHLC(priceData, interval) {
            // If no interval is provided, treat each data point as a separate candle.
            if (!interval) {
                return priceData.map(([time, price]) => ({
                    open: price,
                    high: price,
                    low: price,
                    close: price,
                    time: Math.floor(time)  // use the timestamp as is (or convert it as needed)
                }));
            }

            // Sort the data by timestamp in ascending order.
            const sortedData = priceData.slice().sort((a, b) => a[0] - b[0]);

            const ohlcData = [];
            let currentGroup = null;

            for (let [timestamp, price] of sortedData) {
                // Determine the start of the group interval (e.g. if interval is 60, group by each minute)
                const groupTime = Math.floor(timestamp / interval) * interval;

                // If we're in a new group, push the previous one (if it exists) and start a new group.
                if (!currentGroup || currentGroup.groupTime !== groupTime) {
                    if (currentGroup) {
                        ohlcData.push({
                            open: currentGroup.open,
                            high: currentGroup.high,
                            low: currentGroup.low,
                            close: currentGroup.close,
                            time: currentGroup.groupTime
                        });
                    }
                    currentGroup = {
                        groupTime,
                        open: price,
                        high: price,
                        low: price,
                        close: price
                    };
                } else {
                    // Update the group's OHLC values.
                    currentGroup.high = Math.max(currentGroup.high, price);
                    currentGroup.low = Math.min(currentGroup.low, price);
                    currentGroup.close = price;
                }
            }

            // Push the final group.
            if (currentGroup) {
                ohlcData.push({
                    open: currentGroup.open,
                    high: currentGroup.high,
                    low: currentGroup.low,
                    close: currentGroup.close,
                    time: currentGroup.groupTime
                });
            }

            return ohlcData;
        }

        function aggregateToIntervalAvg(data, interval) {
            const dailyData = {};
            data.forEach(([timestamp, price]) => {
                const dayTimestamp = Math.floor(timestamp / interval) * interval; // Normalize to start of day
                if (!dailyData[dayTimestamp]) {
                    dailyData[dayTimestamp] = {sum: 0, count: 0};
                }
                dailyData[dayTimestamp].sum += price;
                dailyData[dayTimestamp].last = price;
                dailyData[dayTimestamp].count += 1;
            });

            return Object.keys(dailyData).map(day => ({
                time: parseInt(day),
                value: dailyData[day].sum / dailyData[day].count // Compute daily average
                //value: dailyData[day].last // Compute daily average
            }));
        }

        const volumes = {{ volumes|safe }};
        const poolPrices = {{ pool_prices|safe }};
        const cexPrices = {{ cex_prices|safe }};
        const detPrices = {{ det_prices|safe }};

        console.log(JSON.stringify(poolPrices.splice(0, 10)));

        const poolOHLC = convertToOHLC(poolPrices, INTERVAL);
        console.log(poolOHLC);

        function convertToLineData(data) {
            return data.map(([timestamp, price]) => ({
                time: timestamp,
                value: price
            }));
        }

        const detLineData = aggregateToIntervalAvg(detPrices, INTERVAL);
        const cexLineData = aggregateToIntervalAvg(cexPrices, INTERVAL);

        function aggregateSwapVolumes(volumes, interval, key='swap') {
            const dailyVolumes = {};

            volumes.forEach(([timestamp, volumeObj]) => {
                const dayTimestamp = Math.floor(timestamp / interval) * interval; // Normalize to day start
                const swapVolume = volumeObj?.[key] || 0;

                if (!dailyVolumes[dayTimestamp]) {
                    dailyVolumes[dayTimestamp] = 0;
                }
                dailyVolumes[dayTimestamp] += swapVolume; // Sum volumes for the same day
            });

            return Object.keys(dailyVolumes).map(day => ({
                time: parseInt(day),
                value: dailyVolumes[day]
            })).filter(({value}) => value > 0); // Filter out days with no volume
        }

        const chartOptions = {
            handleScroll: false, handleScale: false,
            layout: {
                textColor: 'white', background: {color: 'transparent'},
                fontFamily: 'ThorFontLight',
                fontSize: 20,
            },
            grid: {
                vertLines: {color: '#353535', visible: true},
                horzLines: {color: '#323232', visible: true}
            },

            localization: {
                locale: 'en',
            },

            leftPriceScale: {
                visible: false,
                borderColor: 'rgba(197, 203, 206, 0.8)',
                scaleMargins: {
                    bottom: 0,
                    top: 0.82,
                },
            },
            rightPriceScale: {
                scaleMargins: {
                    bottom: 0.2,
                    top: 0.2,
                },
            },
        };

        const chart = LightweightCharts.createChart(document.getElementById('price-chart'), chartOptions);

        // --- VOLUME SERIES ---

        const volScale = 0.8;

        const volumeSeries = chart.addSeries(LightweightCharts.HistogramSeries, {
            color: 'rgba(80,240,255,0.3)', // Light white for transparency

            priceFormat: {type: 'volume'},
            priceScaleId: '',
            priceLineVisible: false,
            lastValueVisible: false,
            // title: 'Swap volume',
        });
        volumeSeries.priceScale().applyOptions({
            scaleMargins: {
                top: volScale, // highest point of the series will be 70% away from the top
                bottom: 0, // lowest point will be at the very bottom.
            },
        })

        const volumeData = aggregateSwapVolumes(volumes, INTERVAL * 1.5);
        console.log(`Volume data ->`)
        console.log(volumeData);
        volumeSeries.setData(volumeData);

        // trade asset volume
        const volumeSeries2 = chart.addSeries(LightweightCharts.HistogramSeries, {
            color: 'rgba(0, 255, 100, 0.3)', // Light white for transparency

            priceFormat: {type: 'volume'},
            priceScaleId: '',
            {#priceScaleId: 'left',#}
            priceLineVisible: false,
            lastValueVisible: false,
            // title: 'Swap volume',
        });
        volumeSeries2.priceScale().applyOptions({
            scaleMargins: {
                top: volScale, // highest point of the series will be 70% away from the top
                bottom: 0, // lowest point will be at the very bottom.
            },
        })
        // mult by 2
        let volumeData2 = aggregateSwapVolumes(volumes, INTERVAL * 1.5, 'trade_swap');
        volumeSeries2.setData(volumeData2);

        // --- PRICE SERIES ---

        const detSeries = chart.addSeries(LightweightCharts.LineSeries, {
            color: 'rgba(100, 255, 200, 0.9)',
            lineWidth: 3,
            lineStyle: LightweightCharts.LineStyle.Dotted,
            priceLineVisible: false,
        });
        detSeries.setData(detLineData);


        const cexSeries = chart.addSeries(LightweightCharts.LineSeries, {
            // 00CCFF
            color: "rgba(0, 204, 255, 0.8)",
            lineWidth: 1,

            // dashed line
            type: 'line',
            lineStyle: LightweightCharts.LineStyle.Dotted,
            priceLineVisible: false,
        });
        cexSeries.setData(cexLineData);

        const barSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
            upColor: '#26a69a',
            downColor: '#ef5350',
            priceLineVisible: false,
        });
        barSeries.setData(poolOHLC);

        // decorate the chart with an area series (gradient)
        const lineData = poolOHLC.map(datapoint => ({
            time: datapoint.time,
            value: (datapoint.close + datapoint.open) / 2,
        }));

        const areaSeries = chart.addSeries(LightweightCharts.AreaSeries, {
            lastValueVisible: false, // hide the last value marker for this series
            crosshairMarkerVisible: false, // hide the crosshair marker for this series
            lineColor: 'transparent', // hide the line
            topColor: 'rgba(33,110,107,0.3)',
            bottomColor: 'rgba(33,87,110,0.1)',
        });
        // Set the data for the Area Series
        areaSeries.setData(lineData);

        chart.timeScale().fitContent();

        // log max timestamps of all series
        const maxCexPriceTs = cexPrices[cexPrices.length - 1][0];
        const maxDetPriceTs = detPrices[detPrices.length - 1][0];
        const maxPoolPriceTs = poolPrices[poolPrices.length - 1][0];
        const maxVolumeTs = volumes[volumes.length - 1][0];
        console.log(`Max timestamps: CEX: ${maxCexPriceTs}, DET: ${maxDetPriceTs}, POOL: ${maxPoolPriceTs}, VOLUME: ${maxVolumeTs}`);

    </script>

{% endblock %}
