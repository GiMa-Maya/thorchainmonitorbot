import base64
import hashlib
import inspect
import typing

import bech32
import betterproto

import proto.types as thor_type_lib
from proto.cosmos.tx.v1beta1 import Tx
from services.lib.utils import expect_string


def parse_thor_address(addr: bytes, prefix='thor') -> str:
    if isinstance(addr, bytes) and addr.startswith(prefix.encode('utf-8')):
        return addr.decode('utf-8')

    good_bits = bech32.convertbits(list(addr), 8, 5, False)
    return bech32.bech32_encode(prefix, good_bits)


def register_thorchain_messages():
    result = {}
    for k in dir(thor_type_lib):
        v = getattr(thor_type_lib, k)
        if inspect.isclass(v) and issubclass(v, betterproto.Message):
            key = f'/types.{k}'
            result[key] = v
    return result


THORCHAIN_MESSAGES_MAP = register_thorchain_messages()


class NativeThorTx:
    def __init__(self, tx: Tx, tx_hash: str = ''):
        self.tx = tx
        self.hash = tx_hash
        self.code = 0

    @property
    def is_success(self):
        return self.code == 0

    def __repr__(self) -> str:
        return repr(self.tx)

    def __str__(self):
        return str(self.tx)

    @classmethod
    def from_bytes(cls, data: bytes):
        tx = Tx().parse(data)
        messages = []
        for msg in tx.body.messages:
            proto_type = THORCHAIN_MESSAGES_MAP.get(msg.type_url)
            messages.append(
                proto_type().parse(msg.value) if proto_type else msg
            )
        tx.body.messages = messages
        tx_hash = hashlib.sha256(data).hexdigest().upper()
        return cls(tx, tx_hash)

    @classmethod
    def from_base64(cls, data):
        if isinstance(data, str):
            data = data.encode()

        raw_data = base64.decodebytes(data)
        return cls.from_bytes(raw_data)

    @property
    def first_message(self):
        return self.messages[0] if self.messages else None

    @property
    def messages(self):
        return self.tx.body.messages

    @property
    def memo(self):
        memo = self.tx.body.memo
        if not memo and hasattr(self.first_message, 'memo'):
            memo = self.first_message.memo

        if not memo:
            for msg in self.messages:
                if hasattr(msg, 'txs'):
                    for tx in msg.txs:
                        if hasattr(tx, 'memo'):
                            memo = tx.memo
                            break
                        elif hasattr(tx, 'tx'):
                            memo = tx.tx.memo
                            break

        return memo


def thor_decode_amount_field(string: str):
    """ e.g. 114731984rune """
    amt, asset = '', ''
    still_numbers = True

    for symbol in string:
        if not str.isdigit(symbol):
            still_numbers = False
        if still_numbers:
            amt += symbol
        else:
            asset += symbol

    return (int(amt) if amt else 0), asset.strip().upper()


def debase64(s: str):
    if not s:
        return b''
    return base64.decodebytes(s.encode()).decode()


def block_events(block):
    try:
        return block['data']['value']['result_end_block']['events']
    except LookupError:
        return []


class DecodedEvent(typing.NamedTuple):
    type: str
    attributes: typing.Dict[str, str]
    height: int = 0

    @classmethod
    def from_dict(cls, d):
        return cls(
            type=d['type'],
            attributes={attr['key']: attr.get('value') for attr in d['attributes']},
            height=d.get('height', 0)
        )

    @classmethod
    def from_dict_our(cls, d):
        return cls(
            type=d['type'],
            attributes=d['attributes'],
            height=d.get('height', 0)
        )

    @property
    def to_dict(self):
        return {
            'type': self.type,
            'attributes': {
                k: expect_string(v) if isinstance(v, bytes) else v
                for k, v in self.attributes.items()
            },
            'height': int(self.height),
        }


def thor_decode_event(e, height) -> DecodedEvent:
    decoded_attrs = {}
    for attr in e['attributes']:
        key = debase64(attr.get('key'))
        value = debase64(attr.get('value'))
        decoded_attrs[key] = value
        if key == 'amount' or key == 'coin':
            decoded_attrs['amount'], decoded_attrs['asset'] = thor_decode_amount_field(value)

    return DecodedEvent(e.get('type', ''), decoded_attrs, height=height)
